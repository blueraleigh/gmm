#include <R.h>
#include <Rinternals.h>
#include <Rmath.h>

/* 
** This file implements a simple Gaussian mixture model for fitting to 
** real-valued multivariate data using the Expectation-Maximization algorithm. 
** The underlying prior model assumes that latent clusters have distinct 
** centers but that a single diagonal covariance matrix is shared by all 
** clusters. The EM implementation follows the algorithm described in 
** https://doi.org/10.1145/335191.335468.
*/


/* 
** A structure to compute online mean and variance.
** For a description of the method visit:
** https://www.johndcook.com/blog/standard_deviation/ 
*/
struct rs {
    // number of features
    int p;
    // number of observations
    int n;
    // running means
    double *m;
    // running sums of squares
    double *s;
};

static void rs_push(struct rs *rs, double *x, int stride)
{
    rs->n += 1;
    if (rs->n == 1)
    {
        int i;
        int j;
        for (i = 0, j = 0; i < rs->p; ++i, j += stride)
        {
            rs->m[i] = ISNAN(x[j]) ? 0 : x[j];
            rs->s[i] = 0;
        }
    }
    else
    {
        int i;
        int j;
        double m;
        double y;
        for (i = 0, j = 0; i < rs->p; ++i, j += stride)
        {
            m = rs->m[i];
            y = ISNAN(x[j]) ? m : x[j];
            rs->m[i] += (y - m) / rs->n;
            rs->s[i] += (y - m) * (y - rs->m[i]);
        }
    }
}

static double rs_mean(struct rs *rs, int i)
{
    return i < rs->p ? rs->m[i] : R_NaN;
}

static double rs_var(struct rs *rs, int i)
{
    return i < rs->p ? rs->s[i] / (rs->n - 1) : R_NaN;
}

static struct rs *rs_alloc(int p)
{
    struct rs *rs = malloc(sizeof(*rs));
    if (!rs)
        return NULL;
    rs->p = p;
    rs->n = 0;
    rs->m = malloc(2*p*sizeof(double));
    if (!rs->m) 
    {
        free(rs);
        return NULL;
    }
    rs->s = rs->m + p;
    return rs;
}

static void rs_free(struct rs *rs)
{
    if (!rs)
        return;
    free(rs->m);
    free(rs);
}

struct gmm {
    // number of clusters
    int k;
    // number of features
    int p;
    // number of data observations
    int n;
    // cluster means
    double *centers;
    // cluster mixture weights
    double *weights;
    // feature variances
    double *variances;
    // cluster membership probabilities
    double *memberships;
    // workspace for new centers
    double *_c;
    // workspace for new weights
    double *_w;
    // running means and variances
    struct rs *rs;
    // current number of training iterations
    int niter;
    // current log likelihood of fitted mixture
    double lnL;
};

static struct gmm *gmm_alloc(int k, int p, int n)
{
    struct gmm *gmm = malloc(sizeof(*gmm));
    if (!gmm)
        return NULL;
    gmm->k = k;
    gmm->p = p;
    gmm->n = n;
    gmm->centers = calloc(k*p + k + p + n*k + k*p + k, sizeof(double));
    if (!gmm->centers) {
        free(gmm);
        return NULL;
    }
    gmm->weights = gmm->centers + k*p;
    gmm->variances = gmm->weights + k;
    gmm->memberships = gmm->variances + p;
    gmm->_c = gmm->memberships + n*k;
    gmm->_w = gmm->_c + k*p;
    gmm->rs = rs_alloc(p);
    if (!gmm->rs) {
        free(gmm->centers);
        free(gmm);
        return NULL;
    }
    return gmm;
}

static void gmm_free(struct gmm *gmm)
{
    if (!gmm)
        return;
    rs_free(gmm->rs);
    free(gmm->centers);
    free(gmm);
}

static double gmm_estep(struct gmm *gmm, double *x)
{
    int i;
    int j;
    int l;
    double y;
    double w;
    double logp_max;
    double logp[gmm->k];
    double lnL = 0;

    memset(gmm->_w, 0, gmm->k * sizeof(double));
    memset(gmm->_c, 0, gmm->k * gmm->p * sizeof(double));

    for (i = 0; i < gmm->n; ++i)
    {
        // Probability of datum is sum(w(j)*p(datum|j)) over j,
        // where p(datum|j) is the probability of datum given 
        // it was generated by cluster j, which follows a normal
        // distribution with a mean equal to the j-th column of
        // gmm->centers and a diagonal covariance matrix equal
        // to gmm->variances; w(j) is the probability of the
        // a datum being generated from the j-th cluster and
        // is stored in gmm->weights.
        w = 0;
        logp_max = R_NegInf;
        for (j = 0; j < gmm->k; ++j)
        {
            logp[j] = log(gmm->weights[j]);
            for (l = 0; l < gmm->p; ++l)
            {
                y = ISNAN(x[i + l * gmm->n]) ? gmm->centers[j + l * gmm->k] : 
                    x[i + l * gmm->n];
                logp[j] += dnorm(
                    y, 
                    gmm->centers[j + l * gmm->k], 
                    sqrt(gmm->variances[l]), 
                    1);
            }
            if (logp[j] > logp_max)
                logp_max = logp[j];
        }
        lnL += logspace_sum(logp, gmm->k);
        for (j = 0; j < gmm->k; ++j)
            w += gmm->memberships[i + j * gmm->n] = exp(logp[j] - logp_max);
        for (j = 0; j < gmm->k; ++j)
        {
            gmm->memberships[i + j * gmm->n] /= w;
            for (l = 0; l < gmm->p; ++l)
            {
                y = ISNAN(x[i + l * gmm->n]) ? gmm->centers[j + l * gmm->k] : 
                    x[i + l * gmm->n];
                gmm->_c[j + l * gmm->k] += gmm->memberships[i + j * gmm->n] * y;
            }
            gmm->_w[j] += gmm->memberships[i + j * gmm->n];
        }
    }
    return lnL;
}

static void gmm_mstep(struct gmm *gmm, double *x)
{
    int i;
    int j;
    int l;
    double z;
    memset(gmm->variances, 0, gmm->p * sizeof(double));
    for (j = 0; j < gmm->k; ++j) 
    {
        for (l = 0; l < gmm->p; ++l)
            gmm->centers[j + l * gmm->k] = gmm->_c[j + l * gmm->k] / gmm->_w[j];
        gmm->weights[j] = gmm->_w[j] / gmm->n;
    }
    for (i = 0; i < gmm->n; ++i)
    {
        for (j = 0; j < gmm->k; ++j)
        {
            for (l = 0; l < gmm->p; ++l)
            {
                z = ISNAN(x[i + l * gmm->n]) ? 0 : 
                    x[i + l * gmm->n] - gmm->centers[j + l * gmm->k];
                gmm->variances[l] += 
                    (z * gmm->memberships[i + j * gmm->n] * z) / gmm->n;
            }
        }
    }
}

static void gmm_init(struct gmm *gmm, double *x)
{
    int i;
    int j;
    int l;
    for (j = 0; j < gmm->k; ++j)
        gmm->weights[j] = 1 / (double)(gmm->k);
    for (i = 0; i < gmm->n; ++i)
        rs_push(gmm->rs, x + i, gmm->n);
    
    for (l = 0; l < gmm->p; ++l)
    {
        gmm->variances[l] = rgamma(1, 1) * rs_var(gmm->rs, l);
        for (j = 0; j < gmm->k; ++j)
            gmm->centers[j + l * gmm->k] = rnorm(0, 0.1) + rs_mean(gmm->rs, l);
    }

    gmm->lnL = gmm_estep(gmm, x);
    gmm_mstep(gmm, x);
    gmm->niter = 1;
}

static int gmm_step(struct gmm *gmm, double *x)
{
    gmm->niter += 1;
    double lnL = gmm->lnL;
    gmm->lnL = gmm_estep(gmm, x);
    gmm_mstep(gmm, x);
    return (gmm->lnL - lnL) < 1e-6 ? 1 : 0;
}

static void gmm_fit(struct gmm *gmm, double *x, int niter)
{
    int iter = gmm->niter;
    int converged = 0;
    while (iter++ < niter && !converged) 
        converged = gmm_step(gmm, x);
}

SEXP C_gmm_fit(SEXP x, SEXP k, SEXP niter)
{
    int n = INTEGER(getAttrib(x, R_DimSymbol))[0];
    int p = INTEGER(getAttrib(x, R_DimSymbol))[1];

    struct gmm *gmm = gmm_alloc(INTEGER(k)[0], p, n);
    
    GetRNGstate();
    gmm_init(gmm, REAL(x));
    gmm_fit(gmm, REAL(x), INTEGER(niter)[0]);
    PutRNGstate();

    SEXP obj = PROTECT(allocVector(VECSXP, 7));
    SEXP objnames = PROTECT(allocVector(STRSXP, 7));

    SET_STRING_ELT(objnames, 0, mkChar("niter"));
    SET_STRING_ELT(objnames, 1, mkChar("converged"));
    SET_STRING_ELT(objnames, 2, mkChar("logLik"));
    SET_STRING_ELT(objnames, 3, mkChar("k"));
    SET_STRING_ELT(objnames, 4, mkChar("mixture.weights"));
    SET_STRING_ELT(objnames, 5, mkChar("mixture.variances"));
    SET_STRING_ELT(objnames, 6, mkChar("mixture.centers"));

    setAttrib(obj, R_NamesSymbol, objnames);
    UNPROTECT(1);

    SET_VECTOR_ELT(obj, 0, ScalarInteger(gmm->niter));
    SET_VECTOR_ELT(obj, 1, ScalarLogical(gmm->niter < INTEGER(niter)[0]));
    SET_VECTOR_ELT(obj, 2, ScalarReal(gmm->lnL));
    SET_VECTOR_ELT(obj, 3, ScalarInteger(gmm->k));
    SET_VECTOR_ELT(obj, 4, allocVector(REALSXP, gmm->k));
    SET_VECTOR_ELT(obj, 5, allocVector(REALSXP, p));
    SET_VECTOR_ELT(obj, 6, allocMatrix(REALSXP, gmm->k, p));

    memcpy(REAL(VECTOR_ELT(obj, 4)), gmm->weights, gmm->k * sizeof(double));
    memcpy(REAL(VECTOR_ELT(obj, 5)), gmm->variances, gmm->p * sizeof(double));
    memcpy(REAL(VECTOR_ELT(obj, 6)), gmm->centers, gmm->k * gmm->p * sizeof(double));

    if (getAttrib(x, R_DimNamesSymbol) != R_NilValue)
    {
        SEXP dimnames = PROTECT(allocVector(VECSXP, 2));
        SET_VECTOR_ELT(dimnames, 0, R_NilValue);
        SET_VECTOR_ELT(dimnames, 1, 
            VECTOR_ELT(getAttrib(x, R_DimNamesSymbol), 1));
        if (VECTOR_ELT(dimnames, 1) != R_NilValue)
           setAttrib(VECTOR_ELT(obj, 6), R_DimNamesSymbol, dimnames);
        UNPROTECT(1);
    }

    gmm_free(gmm);

    UNPROTECT(1);
    return (obj);
}


SEXP C_gmm_predict(SEXP gmm, SEXP x)
{
    int n = INTEGER(getAttrib(x, R_DimSymbol))[0];
    int p = INTEGER(getAttrib(x, R_DimSymbol))[1];
    int k = INTEGER(VECTOR_ELT(gmm, 3))[0];
    double *weights = REAL(VECTOR_ELT(gmm, 4));
    double *variances = REAL(VECTOR_ELT(gmm, 5));
    double *centers = REAL(VECTOR_ELT(gmm, 6));

    SEXP obj = PROTECT(allocMatrix(REALSXP, n, k));
    double *_x = REAL(x);
    double *y = REAL(obj);

    int i;
    int j;
    int l;
    double z;
    double w;
    double logp[k];
    double logp_max;
    for (i = 0; i < n; ++i)
    {
        w = 0;
        logp_max = R_NegInf;
        for (j = 0; j < k; ++j)
        {
            logp[j] = log(weights[j]);
            for (l = 0; l < p; ++l)
            {
                z = ISNAN(_x[i + l * n]) ? centers[j + l * k] : _x[i + l * n];
                logp[j] += dnorm(
                    z, 
                    centers[j + l * k], 
                    sqrt(variances[l]), 
                    1);
            }
            if (logp[j] > logp_max)
                logp_max = logp[j];
        }
        for (j = 0; j < k; ++j)
            w += y[i + j * n] = exp(logp[j] - logp_max);
        for (j = 0; j < k; ++j)
            y[i + j * n] /= w;
    }
    UNPROTECT(1);
    return obj;
}


#include <R_ext/Rdynload.h>
#include <R_ext/Visibility.h>

#define CALLDEF(name, n)  {#name, (DL_FUNC) &name, n}

static const R_CallMethodDef CallEntries[] = {
    
    CALLDEF(C_gmm_fit, 3),
    CALLDEF(C_gmm_predict, 2),

    {NULL, NULL, 0}
};


void attribute_visible R_init_gmm(DllInfo *info)
{
    R_registerRoutines(info, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(info, FALSE);
    R_forceSymbols(info, TRUE);
}
